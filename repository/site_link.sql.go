// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: site_link.sql

package repository

import (
	"context"
	"database/sql"
)

const getCityData = `-- name: GetCityData :many
SELECT
    date, siteid, city, region, longitude, latitude, level_ne_a, ne_a, interface_a, tlp_a, site_destination, ne_b, interface_b, tlp_b, longitude_destination, latitude_destination, level_ne_b, link, type_transport, bandwith, max_util, capacity, ioh_data_traffic_4g, availability, eut, cqi, prb, accesibility, s1_sr, erab_drop, rrc_sr, erab_sr, inter_freq, intra_freq, irat_hosr, ul_rssi, se_dl, csfb_prep_sr, csfb_sr, syn_ack_ack_delay, syn_syn_ack_delay, downlink_tcp_retransmission_rate, traffic_origin, availability_origin, eut_origin, cqi_origin, prb_origin, accesibility_origin, s1_sr_origin, erab_drop_origin, rrc_sr_origin, erab_sr_origin, inter_freq_origin, intra_freq_origin, irat_hosr_origin, ul_rssi_origin, se_dl_origin, csfb_prep_sr_origin, csfb_sr_origin, syn_ack_ack_delay_origin, syn_syn_ack_delay_origin, downlink_tcp_retransmission_rate_origin
FROM
    demarcation_site_link
WHERE
    city = ?
`

func (q *Queries) GetCityData(ctx context.Context, city string) ([]DemarcationSiteLink, error) {
	rows, err := q.db.QueryContext(ctx, getCityData, city)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DemarcationSiteLink
	for rows.Next() {
		var i DemarcationSiteLink
		if err := rows.Scan(
			&i.Date,
			&i.Siteid,
			&i.City,
			&i.Region,
			&i.Longitude,
			&i.Latitude,
			&i.LevelNeA,
			&i.NeA,
			&i.InterfaceA,
			&i.TlpA,
			&i.SiteDestination,
			&i.NeB,
			&i.InterfaceB,
			&i.TlpB,
			&i.LongitudeDestination,
			&i.LatitudeDestination,
			&i.LevelNeB,
			&i.Link,
			&i.TypeTransport,
			&i.Bandwith,
			&i.MaxUtil,
			&i.Capacity,
			&i.IohDataTraffic4g,
			&i.Availability,
			&i.Eut,
			&i.Cqi,
			&i.Prb,
			&i.Accesibility,
			&i.S1Sr,
			&i.ErabDrop,
			&i.RrcSr,
			&i.ErabSr,
			&i.InterFreq,
			&i.IntraFreq,
			&i.IratHosr,
			&i.UlRssi,
			&i.SeDl,
			&i.CsfbPrepSr,
			&i.CsfbSr,
			&i.SynAckAckDelay,
			&i.SynSynAckDelay,
			&i.DownlinkTcpRetransmissionRate,
			&i.TrafficOrigin,
			&i.AvailabilityOrigin,
			&i.EutOrigin,
			&i.CqiOrigin,
			&i.PrbOrigin,
			&i.AccesibilityOrigin,
			&i.S1SrOrigin,
			&i.ErabDropOrigin,
			&i.RrcSrOrigin,
			&i.ErabSrOrigin,
			&i.InterFreqOrigin,
			&i.IntraFreqOrigin,
			&i.IratHosrOrigin,
			&i.UlRssiOrigin,
			&i.SeDlOrigin,
			&i.CsfbPrepSrOrigin,
			&i.CsfbSrOrigin,
			&i.SynAckAckDelayOrigin,
			&i.SynSynAckDelayOrigin,
			&i.DownlinkTcpRetransmissionRateOrigin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDataByDate = `-- name: GetDataByDate :many
SELECT
    date, siteid, city, region, longitude, latitude, level_ne_a, ne_a, interface_a, tlp_a, site_destination, ne_b, interface_b, tlp_b, longitude_destination, latitude_destination, level_ne_b, link, type_transport, bandwith, max_util, capacity, ioh_data_traffic_4g, availability, eut, cqi, prb, accesibility, s1_sr, erab_drop, rrc_sr, erab_sr, inter_freq, intra_freq, irat_hosr, ul_rssi, se_dl, csfb_prep_sr, csfb_sr, syn_ack_ack_delay, syn_syn_ack_delay, downlink_tcp_retransmission_rate, traffic_origin, availability_origin, eut_origin, cqi_origin, prb_origin, accesibility_origin, s1_sr_origin, erab_drop_origin, rrc_sr_origin, erab_sr_origin, inter_freq_origin, intra_freq_origin, irat_hosr_origin, ul_rssi_origin, se_dl_origin, csfb_prep_sr_origin, csfb_sr_origin, syn_ack_ack_delay_origin, syn_syn_ack_delay_origin, downlink_tcp_retransmission_rate_origin
FROM
    demarcation_site_link
WHERE
    city != ""
`

func (q *Queries) GetDataByDate(ctx context.Context) ([]DemarcationSiteLink, error) {
	rows, err := q.db.QueryContext(ctx, getDataByDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DemarcationSiteLink
	for rows.Next() {
		var i DemarcationSiteLink
		if err := rows.Scan(
			&i.Date,
			&i.Siteid,
			&i.City,
			&i.Region,
			&i.Longitude,
			&i.Latitude,
			&i.LevelNeA,
			&i.NeA,
			&i.InterfaceA,
			&i.TlpA,
			&i.SiteDestination,
			&i.NeB,
			&i.InterfaceB,
			&i.TlpB,
			&i.LongitudeDestination,
			&i.LatitudeDestination,
			&i.LevelNeB,
			&i.Link,
			&i.TypeTransport,
			&i.Bandwith,
			&i.MaxUtil,
			&i.Capacity,
			&i.IohDataTraffic4g,
			&i.Availability,
			&i.Eut,
			&i.Cqi,
			&i.Prb,
			&i.Accesibility,
			&i.S1Sr,
			&i.ErabDrop,
			&i.RrcSr,
			&i.ErabSr,
			&i.InterFreq,
			&i.IntraFreq,
			&i.IratHosr,
			&i.UlRssi,
			&i.SeDl,
			&i.CsfbPrepSr,
			&i.CsfbSr,
			&i.SynAckAckDelay,
			&i.SynSynAckDelay,
			&i.DownlinkTcpRetransmissionRate,
			&i.TrafficOrigin,
			&i.AvailabilityOrigin,
			&i.EutOrigin,
			&i.CqiOrigin,
			&i.PrbOrigin,
			&i.AccesibilityOrigin,
			&i.S1SrOrigin,
			&i.ErabDropOrigin,
			&i.RrcSrOrigin,
			&i.ErabSrOrigin,
			&i.InterFreqOrigin,
			&i.IntraFreqOrigin,
			&i.IratHosrOrigin,
			&i.UlRssiOrigin,
			&i.SeDlOrigin,
			&i.CsfbPrepSrOrigin,
			&i.CsfbSrOrigin,
			&i.SynAckAckDelayOrigin,
			&i.SynSynAckDelayOrigin,
			&i.DownlinkTcpRetransmissionRateOrigin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRegionData = `-- name: GetRegionData :many
SELECT
    date, siteid, city, region, longitude, latitude, level_ne_a, ne_a, interface_a, tlp_a, site_destination, ne_b, interface_b, tlp_b, longitude_destination, latitude_destination, level_ne_b, link, type_transport, bandwith, max_util, capacity, ioh_data_traffic_4g, availability, eut, cqi, prb, accesibility, s1_sr, erab_drop, rrc_sr, erab_sr, inter_freq, intra_freq, irat_hosr, ul_rssi, se_dl, csfb_prep_sr, csfb_sr, syn_ack_ack_delay, syn_syn_ack_delay, downlink_tcp_retransmission_rate, traffic_origin, availability_origin, eut_origin, cqi_origin, prb_origin, accesibility_origin, s1_sr_origin, erab_drop_origin, rrc_sr_origin, erab_sr_origin, inter_freq_origin, intra_freq_origin, irat_hosr_origin, ul_rssi_origin, se_dl_origin, csfb_prep_sr_origin, csfb_sr_origin, syn_ack_ack_delay_origin, syn_syn_ack_delay_origin, downlink_tcp_retransmission_rate_origin
FROM
    demarcation_site_link
WHERE
    region = ?
`

func (q *Queries) GetRegionData(ctx context.Context, region sql.NullString) ([]DemarcationSiteLink, error) {
	rows, err := q.db.QueryContext(ctx, getRegionData, region)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DemarcationSiteLink
	for rows.Next() {
		var i DemarcationSiteLink
		if err := rows.Scan(
			&i.Date,
			&i.Siteid,
			&i.City,
			&i.Region,
			&i.Longitude,
			&i.Latitude,
			&i.LevelNeA,
			&i.NeA,
			&i.InterfaceA,
			&i.TlpA,
			&i.SiteDestination,
			&i.NeB,
			&i.InterfaceB,
			&i.TlpB,
			&i.LongitudeDestination,
			&i.LatitudeDestination,
			&i.LevelNeB,
			&i.Link,
			&i.TypeTransport,
			&i.Bandwith,
			&i.MaxUtil,
			&i.Capacity,
			&i.IohDataTraffic4g,
			&i.Availability,
			&i.Eut,
			&i.Cqi,
			&i.Prb,
			&i.Accesibility,
			&i.S1Sr,
			&i.ErabDrop,
			&i.RrcSr,
			&i.ErabSr,
			&i.InterFreq,
			&i.IntraFreq,
			&i.IratHosr,
			&i.UlRssi,
			&i.SeDl,
			&i.CsfbPrepSr,
			&i.CsfbSr,
			&i.SynAckAckDelay,
			&i.SynSynAckDelay,
			&i.DownlinkTcpRetransmissionRate,
			&i.TrafficOrigin,
			&i.AvailabilityOrigin,
			&i.EutOrigin,
			&i.CqiOrigin,
			&i.PrbOrigin,
			&i.AccesibilityOrigin,
			&i.S1SrOrigin,
			&i.ErabDropOrigin,
			&i.RrcSrOrigin,
			&i.ErabSrOrigin,
			&i.InterFreqOrigin,
			&i.IntraFreqOrigin,
			&i.IratHosrOrigin,
			&i.UlRssiOrigin,
			&i.SeDlOrigin,
			&i.CsfbPrepSrOrigin,
			&i.CsfbSrOrigin,
			&i.SynAckAckDelayOrigin,
			&i.SynSynAckDelayOrigin,
			&i.DownlinkTcpRetransmissionRateOrigin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCity = `-- name: ListCity :many
SELECT
    distinct(city)
FROM
    demarcation_site_link
WHERE
    city != ""
`

func (q *Queries) ListCity(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listCity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var city string
		if err := rows.Scan(&city); err != nil {
			return nil, err
		}
		items = append(items, city)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRegion = `-- name: ListRegion :many
SELECT
    distinct(region)
FROM
    demarcation_site_link
`

func (q *Queries) ListRegion(ctx context.Context) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, listRegion)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var region sql.NullString
		if err := rows.Scan(&region); err != nil {
			return nil, err
		}
		items = append(items, region)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
